# Hash Table 刷题指南（中文）

本指南按哈希表使用模式分组，覆盖目前 `HashTable` 目录下的题目。每个分组先总结通用套路，再列出对应题目、关键思路、复杂度与常见坑，帮助你在复习时快速定位思路。

## A. 互补 / 前缀 / 状态作键
针对“在线匹配互补值”或“前缀状态快速回查”的场景，哈希表保存的是已经出现过的前缀或需要匹配的状态，换取 O(1) 的互补查询。

### LC 1. Two Sum
- **核心思路**：遍历数组，维护 `value -> index`；每次查询 `target - num` 是否已出现。
- **复杂度**：时间 O(n)，空间 O(n)。
- **易错点**：注意不能把当前元素放进表后再查互补（会与自己匹配）；返回索引即可，元素可能重复。

### LC 560. Subarray Sum Equals K
- **核心思路**：前缀和 + 计数哈希表，存储 `prefix -> 出现次数`，统计 `prefix - k` 的出现次数。
- **复杂度**：时间 O(n)，空间 O(n)。
- **易错点**：初始化 `prefix_count[0] = 1` 处理从头开始的子数组；数组元素可为负数，不能提前剪枝。

### LC 525. Contiguous Array
- **核心思路**：把 0 当成 -1 计算前缀“平衡值”，记录每个平衡值首次出现索引，遇到重复即可得到最长区间。
- **复杂度**：时间 O(n)，空间 O(n)。
- **易错点**：必须记录“最早”索引才能最大化长度；平衡值为 0 时区间从头开始。

### LC 523. Continuous Subarray Sum
- **核心思路**：前缀和对 k 取模，若同余值再次出现且距离 ≥ 2，则存在和为 k 倍数的子数组。
- **复杂度**：时间 O(n)，空间 O(min(n,k))。
- **易错点**：`k` 可能为负，注意统一取模处理；数组长度要满足至少 2。

### LC 437. Path Sum III
- **核心思路**：树上 DFS 维护路径前缀和，哈希表存 `prefix -> 计数`，回溯时撤销状态，查询 `prefix - target`。
- **复杂度**：时间 O(n)，空间 O(h)（递归栈 + 有效前缀）。
- **易错点**：回溯时必须 `-1`；初始化 `{0:1}` 以处理从根节点开始的路径。

### LC 957. Prison Cells After N Days
- **核心思路**：把 8 个格子的状态编码为元组或 bitmask，哈希表记录该状态首次出现的天数；遇到循环即可用取模跳步。
- **复杂度**：时间 O(循环长度) ≤ 2^6，空间 O(循环长度)。
- **易错点**：首尾格子的邻居恒定为 0；循环出现后别忘记对剩余天数取模再模拟。

## B. 双向映射 / 一一映射校验
当需要验证两个集合是否一一对应时，同时维护双向映射，避免“多对一”或“一对多”。

### LC 205. Isomorphic Strings
- **核心思路**：并行遍历 s、t，维护 `s->t` 与 `t->s` 两张表，任一方向冲突即失败。
- **复杂度**：时间 O(n)，空间 O(Σ)。
- **易错点**：长度不同直接返回 False；字符不限于小写字母，要覆盖完整 ASCII。

### LC 290. Word Pattern
- **核心思路**：先切分字符串，长度与 pattern 不同直接失败；同步维护 `char->word` 和 `word->char`。
- **复杂度**：时间 O(n)，空间 O(k)。
- **易错点**：注意单词之间只有单个空格；模式字符和单词都不能重复绑定。

## C. 根据“值的签名”分组
统一化字符串、数组或文件的特征，哈希表以“签名”为键，把同类元素归类，实现倒排索引式分组。

### LC 49. Group Anagrams
- **核心思路**：对字符串排序或统计 26 频次向量作为签名，`signature -> list`。
- **复杂度**：时间 O(n * L log L) 或 O(n * L)，空间 O(n * L)。
- **易错点**：频次签名更快也更稳；注意 Unicode 与大小写的处理要求。

### LC 2352. Equal Row and Column Pairs
- **核心思路**：将每行序列化为元组计数，再逐列生成签名并查询频次。
- **复杂度**：时间 O(n^2)，空间 O(n^2)。
- **易错点**：字典键必须是不可变类型（元组）；重复行要累加次数。

### LC 249. Group Shifted Strings
- **核心思路**：以相邻字符差值 mod 26 作为签名，同一平移类的字符串差值序列一致。
- **复杂度**：时间 O(n * L)，空间 O(n * L)。
- **易错点**：单字符字符串签名为空元组；记得 mod 26 处理 z→a 的回绕。

### LC 609. Find Duplicate File in System
- **核心思路**：解析目录字符串，内容 `content` 作为键，收集路径列表，最后筛出长度 > 1 的分组。
- **复杂度**：时间 O(m * L)，空间 O(m * L)。
- **易错点**：字符串解析要准确定位括号；不要遗忘只出现一次的内容需要排除。

## D. 值 → 位置 / 统计（倒排定位原元素）
把值映射到它的索引、队列或统计信息，常用于快速回溯位置或组合索引。

### LC 219. Contains Duplicate II
- **核心思路**：`value -> lastIndex`，每次更新前检查距离是否 ≤ k。
- **复杂度**：时间 O(n)，空间 O(min(n,k))。
- **易错点**：`k = 0` 时无解；更新索引要覆盖旧值，防止错误距离。

### LC 599. Minimum Index Sum of Two Lists
- **核心思路**：先构建 `restaurant -> idx_in_list1`，再扫描第二个列表维护当前最小索引和候选集合。
- **复杂度**：时间 O(n + m)，空间 O(n)。
- **易错点**：可能存在多个最优解，记得并列加入；餐厅名称可能含空格，不要再分词。

### LC 760. Find Anagram Mappings
- **核心思路**：`value -> indices in B`（栈/队列），扫描 A 时弹出一个索引作为映射。
- **复杂度**：时间 O(n)，空间 O(n)。
- **易错点**：元素可能重复，多索引必须全部保存；推荐 `pop()` 从末尾拿，避免 O(n)。

### LC 398. Random Pick Index
- **核心思路**：预处理 `value -> indices`，`pick(target)` 时用 `random.choice` 均匀抽样；或使用水库抽样在线处理。
- **复杂度**：预处理 O(n)，单次查询 O(1)。
- **易错点**：不要修改原列表；若选择水库抽样，每次 pick 需要重新扫描数组。

### LC 1331. Rank Transform of an Array
- **核心思路**：取集合去重、排序后赋予递增 rank，存入 `value -> rank`，还原到原数组。
- **复杂度**：时间 O(n log n)，空间 O(n)。
- **易错点**：数组可能为空；排名从 1 开始；负数同样参与排序。

## E. 频次 / 桶作为键
以“出现次数”反查元素，实现 Top-K、排序或唯一性检查等频次驱动的问题。

### LC 347. Top K Frequent Elements
- **核心思路**：先统计频次，再使用桶排序（`count -> values`）或最大堆取前 K 个高频元素。
- **复杂度**：桶解法时间 O(n)，空间 O(n)。
- **易错点**：当 K 接近元素种类数时，桶排序更高效；堆法注意 Python `heapq` 是小根堆。

### LC 451. Sort Characters by Frequency
- **核心思路**：统计字符频次，按频次降序重建字符串，可用桶或排序键 `(count, char)`。
- **复杂度**：时间 O(n) 或 O(n log Σ)，空间 O(Σ)。
- **易错点**：尽量避免重复拼接字符串，使用列表 join；大小写敏感。

### LC 1338. Reduce Array Size to the Half
- **核心思路**：统计频次并按降序排序，贪心移除高频元素直到删除数量 ≥ n/2。
- **复杂度**：时间 O(n log n)，空间 O(n)。
- **易错点**：半数阈值需要向上取整；一旦满足条件立即返回减少遍历。

### LC 1207. Unique Number of Occurrences
- **核心思路**：统计次数后检查次数集合是否有重复，可用 `seen` 集合。
- **复杂度**：时间 O(n)，空间 O(n)。
- **易错点**：注意负数同样可作为键；如果出现重复频次立即返回 False。

## F. 图 / 关系类映射
把元素视作图节点，用哈希表保存邻接关系，快速回答“是否直接相关”的查询。

### LC 734. Sentence Similarity
- **核心思路**：构建无向邻接表 `word -> set(neighbors)`；逐词比较，两者相同或互为邻居则继续。
- **复杂度**：时间 O(n + m)，空间 O(m)。
- **易错点**：相似关系不传递，不要过度推断；句子长度必须一致。

## 复习建议
- 先按分组刷题，理解“键是什么”“值存什么”——这是哈希表应用的核心。
- 同一分组内的题目可一起回顾代码模板（如前缀和、双射、频次桶等），巩固套路。
- 结合目录中的 Notebook，按题号回看详细笔记与代码实现，快速复盘细节。
